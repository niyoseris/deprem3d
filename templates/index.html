<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Earthquake Visualization</title>
    <script src="https://cesium.com/downloads/cesiumjs/releases/1.111/Build/Cesium/Cesium.js"></script>
    <link href="https://cesium.com/downloads/cesiumjs/releases/1.111/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
    <style>
        #cesiumContainer {
            width: 100%;
            height: 80vh;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        .earthquake-info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 5px;
            z-index: 999;
        }
        .filter-form {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 5px;
            z-index: 999;
        }
        .coordinates {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 5px;
            z-index: 999;
        }
    </style>
</head>
<body>
    <div id="cesiumContainer"></div>
    <div class="coordinates">
        <h4>Current Coordinates</h4>
        <p id="currentCoordinates">Lat: 0, Lon: 0</p>
    </div>
    <div class="filter-form">
        <h4>Filter</h4>
        <form id="filterForm">
            <label for="minMagnitude">Minimum Magnitude:</label>
            <input type="number" id="minMagnitude" name="minMagnitude" value="4.5" step="0.1" min="0" required>
            <br>
            <label for="dateRange">Date Range:</label>
            <select id="dateRange">
                <option value="24h">Last 24 Hours</option>
                <option value="3d">Last 3 Days</option>
                <option value="1w">Last 1 Week</option>
                <option value="1m">Last 1 Month</option>
                <option value="1y">Last 1 Year</option>
                <option value="custom">Custom</option>
            </select>
            <br>
            <div class="form-group">
                <label for="startDate">Start Date:</label>
                <input type="date" id="startDate" name="startDate">
            </div>
            <div class="form-group">
                <label for="endDate">End Date:</label>
                <input type="date" id="endDate" name="endDate">
            </div>
            <div class="form-group">
                <label for="minDepth">Minimum Depth (km):</label>
                <input type="number" class="form-control" id="minDepth" name="minDepth" value="0">
            </div>
            <div class="form-group">
                <label for="maxDepth">Maximum Depth (km):</label>
                <input type="number" class="form-control" id="maxDepth" name="maxDepth" value="700">
            </div>
            <button type="submit">Filter</button>
        </form>
        <br>
        <label>
            <input type="checkbox" id="toggleLabels" checked>
            Show Earthquake Information
        </label>
    </div>
    <script>
        // Cesium ion access token
        Cesium.Ion.defaultAccessToken = '{{ cesium_token }}';

        let viewer;
        let showLabels = true;

        async function initCesium() {
            const terrainProvider = await Cesium.createWorldTerrainAsync();
            
            // Initialize the Cesium Viewer
            viewer = new Cesium.Viewer('cesiumContainer', {
                terrainProvider: terrainProvider,
                animation: false,
                baseLayerPicker: false,
                fullscreenButton: false,
                vrButton: false,
                geocoder: false,
                homeButton: false,
                infoBox: true,
                sceneModePicker: false,
                selectionIndicator: false,
                timeline: false,
                navigationHelpButton: false,
                scene3DOnly: true,
                imageryProvider: new Cesium.TileMapServiceImageryProvider({
                    url: Cesium.buildModuleUrl('Assets/Textures/NaturalEarthII')
                })
            });

            // Enable lighting based on sun/moon positions
            viewer.scene.globe.enableLighting = true;

            // Add Bing Maps imagery from Cesium ion
            try {
                const imageryLayer = await Cesium.ImageryLayer.fromProviderAsync(
                    await Cesium.IonImageryProvider.fromAssetId(3)
                );
                viewer.imageryLayers.add(imageryLayer);
            } catch (error) {
                console.error('Error loading imagery:', error);
            }

            // Fetch earthquakes and add them to the map
            fetchEarthquakes();

            // Update coordinates
            updateCoordinates();
            viewer.clock.onTick.addEventListener(updateCoordinates);
        }

        function updateCoordinates() {
            const camera = viewer.camera;
            const position = camera.positionCartographic;
            const lon = Cesium.Math.toDegrees(position.longitude);
            const lat = Cesium.Math.toDegrees(position.latitude);
            document.getElementById('currentCoordinates').innerText = `Lat: ${lat.toFixed(4)}, Lon: ${lon.toFixed(4)}`;
        }

        async function fetchEarthquakes() {
            const minMagnitude = document.getElementById('minMagnitude').value;
            
            // Date range check
            let startDate, endDate;
            const dateRange = document.getElementById('dateRange').value;
            const now = new Date();

            if (dateRange === '24h') {
                startDate = new Date(now.getTime() - 24 * 60 * 60 * 1000);
                endDate = now;
            } else if (dateRange === '3d') {
                startDate = new Date(now.getTime() - 3 * 24 * 60 * 60 * 1000);
                endDate = now;
            } else if (dateRange === '1w') {
                startDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
                endDate = now;
            } else if (dateRange === '1m') {
                startDate = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
                endDate = now;
            } else if (dateRange === '1y') {
                startDate = new Date(now.getTime() - 365 * 24 * 60 * 60 * 1000);
                endDate = now;
            } else {
                startDate = new Date(document.getElementById('startDate').value);
                endDate = new Date(document.getElementById('endDate').value);
            }

            const minDepth = document.getElementById('minDepth').value;
            const maxDepth = document.getElementById('maxDepth').value;

            // Get the boundaries of the displayed area
            const rectangle = viewer.camera.computeViewRectangle();
            const west = Cesium.Math.toDegrees(rectangle.west);
            const east = Cesium.Math.toDegrees(rectangle.east);
            const south = Cesium.Math.toDegrees(rectangle.south);
            const north = Cesium.Math.toDegrees(rectangle.north);

            // Calculate the center point
            const centerLon = (west + east) / 2;
            const centerLat = (south + north) / 2;
            
            // Calculate the radius (distance to the farthest corner)
            const radius = Math.max(
                Cesium.Cartesian3.distance(
                    Cesium.Cartesian3.fromDegrees(west, south),
                    Cesium.Cartesian3.fromDegrees(centerLon, centerLat)
                ),
                Cesium.Cartesian3.distance(
                    Cesium.Cartesian3.fromDegrees(east, north),
                    Cesium.Cartesian3.fromDegrees(centerLon, centerLat)
                )
            ) / 1000; // convert meters to kilometers

            const response = await fetch(`/get_earthquakes?minMagnitude=${minMagnitude}&minDepth=${minDepth}&maxDepth=${maxDepth}&startDate=${startDate.toISOString().split('T')[0]}&endDate=${endDate.toISOString().split('T')[0]}&lat=${centerLat}&lon=${centerLon}&radius=${radius}`);
            const data = await response.json();
            data.features.forEach(earthquake => {
                addEarthquake(earthquake);
            });
        }

        function addEarthquake(earthquake) {
            const lon = earthquake.geometry.coordinates[0];
            const lat = earthquake.geometry.coordinates[1];
            const depth = earthquake.geometry.coordinates[2];
            
            // Earthquake center point (underground)
            const position = Cesium.Cartesian3.fromDegrees(
                lon,
                lat,
                -depth * -1000 // convert km to meters
            );

            // Surface point (directly above the earthquake)
            const surfacePosition = Cesium.Cartesian3.fromDegrees(
                lon,
                lat,
                0
            );

            const magnitude = earthquake.properties.mag;

            // Depth line color (based on magnitude)
            const color = Cesium.Color.fromHsl(
                (1.0 - Math.min(magnitude / 10, 1)) * 0.5, // Magnitude increases towards red
                1.0,
                0.5
            );

            // Depth line
            viewer.entities.add({
                polyline: {
                    positions: [surfacePosition, position],
                    width: Math.max(2, magnitude),
                    material: new Cesium.PolylineGlowMaterialProperty({
                        glowPower: 0.2,
                        color: color
                    })
                }
            });

            // Earthquake point
            viewer.entities.add({
                position: position,
                point: {
                    pixelSize: Math.max(10, magnitude * 3),
                    color: color,
                    outlineColor: Cesium.Color.WHITE,
                    outlineWidth: 2,
                    scaleByDistance: new Cesium.NearFarScalar(1.5e2, 2.0, 1.5e7, 0.5)
                },
                label: {
                    text: `M${magnitude.toFixed(1)}\n${depth} km\n${earthquake.properties.place}`,
                    font: '14px sans-serif',
                    fillColor: Cesium.Color.WHITE,
                    outlineColor: Cesium.Color.BLACK,
                    outlineWidth: 2,
                    style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                    verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
                    pixelOffset: new Cesium.Cartesian2(0, -10),
                    distanceDisplayCondition: new Cesium.DistanceDisplayCondition(0, 10000000),
                    show: showLabels
                },
                description: `
                    <h2>Earthquake Information</h2>
                    <p>Location: ${earthquake.properties.place}</p>
                    <p>Magnitude: ${magnitude}</p>
                    <p>Depth: ${depth} km</p>
                    <p>Time: ${new Date(earthquake.properties.time).toLocaleString()}</p>
                `
            });

            // Surface point marker
            viewer.entities.add({
                position: surfacePosition,
                point: {
                    pixelSize: 5,
                    color: color.withAlpha(0.5),
                    outlineColor: Cesium.Color.WHITE,
                    outlineWidth: 1
                }
            });
        }

        document.getElementById('filterForm').addEventListener('submit', function(event) {
            event.preventDefault(); // Prevent default form behavior
            viewer.entities.removeAll(); // Clear previous earthquakes
            fetchEarthquakes(); // Fetch new earthquakes
        });

        document.getElementById('toggleLabels').addEventListener('change', function() {
            showLabels = this.checked;
            viewer.entities.values.forEach(entity => {
                if (entity.label) {
                    entity.label.show = showLabels;
                }
            });
        });

        initCesium();
    </script>
</body>
</html>
